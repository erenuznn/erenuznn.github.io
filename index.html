<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>ThingSpeak Channel 1 Dashboard</title>
	<!-- Removed external font for minimal academic style -->
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<style>
		:root {
			--bg: #ffffff;
			--panel: #ffffff;
			--text: #222222;
			--muted: #666666;
			--border: #e5e5e5;
			--accent: #222222;
		}
		* { box-sizing: border-box; }
		body {
			margin: 0;
			font-family: Georgia, "Times New Roman", Times, serif;
			background: var(--bg);
			color: var(--text);
			min-height: 100vh;
			padding: 24px;
		}
		header {
			display: flex;
			flex-wrap: wrap;
			justify-content: space-between;
			align-items: center;
			gap: 12px;
			margin-bottom: 18px;
		}
		h1 { margin: 0; font-size: 1.6rem; letter-spacing: 0.4px; }
		.controls {
			display: flex;
			gap: 10px;
			flex-wrap: wrap;
		}
		input, button, select {
			border: 1px solid rgba(255,255,255,0.08);
			background: var(--panel);
			color: var(--text);
			padding: 10px 12px;
			border-radius: 10px;
			font-size: 0.95rem;
			outline: none;
		}
		input:focus, select:focus { border-color: var(--accent); }
		button {
			cursor: pointer;
			background: #ffffff;
			border: 1px solid var(--border);
			color: var(--text);
			font-weight: 600;
			transition: background 120ms ease;
			box-shadow: none;
			border-radius: 4px;
		}
		button:hover { background: #f6f6f6; }
		button:active { background: #eeeeee; }
		.grid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
			gap: 12px;
		}
		#chartsGrid {
			grid-template-columns: repeat(4, 1fr);
			gap: 4px;
		}
		.card {
			background: #ffffff;
			border: 1px solid var(--border);
			border-radius: 6px;
			padding: 12px 14px;
			box-shadow: none;
		}
		.card h3 { margin: 0 0 6px; font-size: 0.95rem; color: var(--muted); font-weight: 600; }
		.value { font-size: 1.2rem; font-weight: 600; color: var(--text); }
		.muted { color: var(--muted); font-size: 0.85rem; }
		#chartsGrid .card {
			padding: 4px 6px;
		}
		#chartsGrid .card h3 {
			margin: 0 0 2px;
			font-size: 0.72rem;
		}
		canvas {
			max-width: 100%;
			height: auto !important;
		}
		#chartsGrid canvas {
			width: 100% !important;
			height: 180px !important;
		}
		.status { margin-top: 8px; }
		.status span { padding: 0; border-radius: 0; font-size: 0.9rem; }
		.ok { color: var(--text); }
		.err { color: #8a1c1c; }
		.chart-wrap { margin-top: 18px; background: #ffffff; border: 1px solid var(--border); border-radius: 6px; padding: 12px; }
		.footer { margin-top: 18px; color: var(--muted); font-size: 0.85rem; }
		.modal {
			display: none;
			position: fixed;
			top: 0; left: 0; right: 0; bottom: 0;
			background: rgba(0,0,0,0.6);
			z-index: 1000;
			justify-content: center;
			align-items: center;
		}
		.modal.show { display: flex; }
		.modal-content {
			background: #ffffff;
			border: 1px solid var(--border);
			border-radius: 6px;
			padding: 20px;
			max-width: 420px;
			box-shadow: none;
		}
		.modal-content h2 { margin: 0 0 12px; color: var(--text); font-size: 1.2rem; }
		.stat-row {
			display: flex;
			justify-content: space-between;
			padding: 10px 0;
			border-bottom: 1px solid rgba(255,255,255,0.05);
			font-size: 0.95rem;
		}
		.stat-row:last-child { border-bottom: none; }
		.stat-label { color: var(--muted); }
		.stat-value { font-weight: 600; color: var(--text); }
		.modal-close {
			margin-top: 16px;
			width: 100%;
			padding: 10px 12px;
			background: #ffffff;
			border: 1px solid var(--border);
			color: var(--text);
			border-radius: 4px;
			font-weight: 600;
			cursor: pointer;
		}
		.modal-close:hover { background: #f6f6f6; }
	</style>
</head>
<body>
	<header>
		<h1>ðŸŒ± Plant Dashboard â€“ Live View</h1>
		<div class="controls">
			<select id="channelSelect" aria-label="Choose plant">
				<option value="channel1" selected>Plant 1</option>
				<option value="channel2">Plant 2</option>
				<option value="channel3">Plant 3</option>
				<option value="channel4">Plant 4</option>
			</select>
			<input id="channelId" type="text" placeholder="Channel ID" aria-label="Channel ID" style="display:none">
			<input id="readKey" type="text" placeholder="Read API Key" aria-label="Read API Key" style="display:none">
			<select id="resultCount" aria-label="Number of results">
				<option value="10">Last 10</option>
				<option value="20" selected>Last 20</option>
				<option value="40">Last 40</option>
			</select>
			<button id="refreshBtn">Refresh Now</button>
			<button id="toggleViewBtn" title="Toggle single/multi plot view">Show All</button>
			<button id="statsBtn">Statistics</button>
		</div>
	</header>

	<div id="statsModal" class="modal">
		<div class="modal-content">
			<h2 id="statsTitle">Statistics</h2>
			<div id="statsBody"></div>
			<button class="modal-close" id="statsClose">Close</button>
		</div>
	</div>

	<div class="grid" id="cards"></div>

	<div class="chart-wrap" id="singleChartWrap">
		<canvas id="chart" height="140"></canvas>
	</div>

	<div id="chartsGrid" class="grid" style="display:none"></div>

	<div class="footer" id="status">Waiting for inputâ€¦</div>

	<script>
		// Replace with your defaults if desired
		const channels = {
			channel1: { id: '3218426', readKey: 'OZMYFFI8039HAYSD', label: 'Plant 1' },
			channel2: { id: '3228048', readKey: 'YJMT4N3SMOW5WKCS', label: 'Plant 2' },
			channel3: { id: '3228049', readKey: 'WA8XTZSTE1LGTQAG', label: 'Plant 3' },
			channel4: { id: '3228050', readKey: 'ADPTYIZIVTDKSVZE', label: 'Plant 4' },
		};
		const DEFAULT_CHANNEL_ID = channels.channel1.id;
		const DEFAULT_READ_KEY = channels.channel1.readKey;

		const cardsEl = document.getElementById('cards');
		const statusEl = document.getElementById('status');
		const channelSelect = document.getElementById('channelSelect');
		const channelInput = document.getElementById('channelId');
		const keyInput = document.getElementById('readKey');
		const resultSelect = document.getElementById('resultCount');
		const fieldSelect = document.createElement('select');
		fieldSelect.id = 'fieldSelect';
		fieldSelect.ariaLabel = 'Field to plot';
		const refreshBtn = document.getElementById('refreshBtn');
		const toggleViewBtn = document.getElementById('toggleViewBtn');
		const statsBtn = document.getElementById('statsBtn');
		const statsModal = document.getElementById('statsModal');
		const statsClose = document.getElementById('statsClose');

		// Insert field selector into controls
		resultSelect.insertAdjacentElement('afterend', fieldSelect);

		let chart;
		let isMulti = false;
		let multiCharts = [];
		let lastFeeds = [];

		channelInput.value = DEFAULT_CHANNEL_ID;
		keyInput.value = DEFAULT_READ_KEY;

		const fieldNames = {
			field1: 'Leaf Temp',
			field2: 'Ambient Temp',
			field3: 'Relative Humidity',
			field4: 'Leaf Cap',
			field5: 'CWSI',
			field6: 'VPD',
			field7: 'Pump Status',
			field8: 'Error'
		};

		const fieldUnits = {
			field1: 'Â°C',
			field2: 'Â°C',
			field3: '%',
			field4: 'pF',
			field5: '',
			field6: 'kPa',
			field7: '',
			field8: ''
		};

		function setStatus(msg, ok = true) {
			statusEl.textContent = msg;
			statusEl.className = ok ? 'ok status' : 'err status';
		}

		function formatValue(fieldKey, val) {
			if (val === null || val === undefined || val === '') return 'â€”';
			const num = parseFloat(val);
			const unit = fieldUnits[fieldKey] || '';
			if (Number.isFinite(num)) {
				return unit ? `${num} ${unit}` : `${num}`;
			}
			return val;
		}

		function calculateStats(data) {
			const vals = data.filter(v => Number.isFinite(v));
			if (!vals.length) return null;
			const n = vals.length;
			const sum = vals.reduce((a, b) => a + b, 0);
			const mean = sum / n;
			const variance = vals.reduce((a, v) => a + (v - mean) ** 2, 0) / n;
			const stdDev = Math.sqrt(variance);
			const sorted = [...vals].sort((a, b) => a - b);
			const median = n % 2 === 0 ? (sorted[n / 2 - 1] + sorted[n / 2]) / 2 : sorted[Math.floor(n / 2)];
			return {
				count: n,
				min: Math.min(...vals),
				max: Math.max(...vals),
				mean: mean,
				median: median,
				stdDev: stdDev
			};
		}

		function showStats() {
			const selectedField = fieldSelect.value || 'field1';
			const data = lastFeeds.map(f => parseFloat(f[selectedField]));
			const stats = calculateStats(data);
			if (!stats) {
				setStatus('No valid data for statistics', false);
				return;
			}
			const unit = fieldUnits[selectedField] || '';
			const unitStr = unit ? ` ${unit}` : '';
			const statsBody = document.getElementById('statsBody');
			statsBody.innerHTML = `
				<div class="stat-row">
					<span class="stat-label">Count</span>
					<span class="stat-value">${stats.count}</span>
				</div>
				<div class="stat-row">
					<span class="stat-label">Min</span>
					<span class="stat-value">${stats.min.toFixed(2)}${unitStr}</span>
				</div>
				<div class="stat-row">
					<span class="stat-label">Max</span>
					<span class="stat-value">${stats.max.toFixed(2)}${unitStr}</span>
				</div>
				<div class="stat-row">
					<span class="stat-label">Mean</span>
					<span class="stat-value">${stats.mean.toFixed(2)}${unitStr}</span>
				</div>
				<div class="stat-row">
					<span class="stat-label">Median</span>
					<span class="stat-value">${stats.median.toFixed(2)}${unitStr}</span>
				</div>
				<div class="stat-row">
					<span class="stat-label">Std Dev</span>
					<span class="stat-value">${stats.stdDev.toFixed(2)}${unitStr}</span>
				</div>
			`;
			document.getElementById('statsTitle').textContent = `Statistics: ${fieldNames[selectedField]}`;
			statsModal.classList.add('show');
		}

		function buildFieldSelector() {
			fieldSelect.innerHTML = '';
			Object.entries(fieldNames).forEach(([key, label], idx) => {
				const opt = document.createElement('option');
				opt.value = key;
				opt.textContent = `${label}`;
				if (idx === 0) opt.selected = true;
				fieldSelect.appendChild(opt);
			});
		}

		function buildCards(feeds) {
			cardsEl.innerHTML = '';
			if (!feeds.length) return;

			// For each field, find the most recent non-null value
			const latestPerField = {};
			const keys = Object.keys(fieldNames);
			for (let i = feeds.length - 1; i >= 0; i--) {
				const f = feeds[i];
				keys.forEach(k => {
					if (!latestPerField[k] && f[k] !== null && f[k] !== undefined && f[k] !== '') {
						latestPerField[k] = { value: f[k], ts: f.created_at };
					}
				});
				// Break early if we already found all
				if (keys.every(k => latestPerField[k])) break;
			}

			keys.forEach(k => {
				const entry = latestPerField[k];
				const displayVal = formatValue(k, entry ? entry.value : null);
				const ts = entry ? new Date(entry.ts).toLocaleString() : 'â€”';
				const card = document.createElement('div');
				card.className = 'card';
				card.innerHTML = `
					<h3>${fieldNames[k]}</h3>
					<div class="value">${displayVal}</div>
					<div class="muted">Updated: ${ts}</div>
				`;
				cardsEl.appendChild(card);
			});
		}

		function updateChart(feeds) {
			if (!feeds.length) return;
			const selectedField = fieldSelect.value || 'field1';
			const labels = feeds.map(f => new Date(f.created_at).toLocaleTimeString());
			const data = feeds.map(f => parseFloat(f[selectedField])).map(v => (Number.isFinite(v) ? v : null));
			const unit = fieldUnits[selectedField] || '';
			const label = unit ? `${fieldNames[selectedField]} [${unit}]` : `${fieldNames[selectedField]}`;
			if (chart) chart.destroy();
			chart = new Chart(document.getElementById('chart'), {
				type: 'line',
				data: {
					labels,
					datasets: [{
						label,
						data,
						borderColor: '#222222',
						backgroundColor: 'transparent',
						tension: 0,
						fill: false,
						pointRadius: 2,
						spanGaps: true
					}]
				},
				options: {
					plugins: { legend: { labels: { color: '#222222' } } },
					scales: {
						x: { ticks: { color: '#444444' }, grid: { color: '#eeeeee' } },
						y: { ticks: { color: '#444444' }, grid: { color: '#eeeeee' } }
					}
				}
			});
		}

		function destroyMultiCharts() {
			multiCharts.forEach(c => c && c.destroy && c.destroy());
			multiCharts = [];
		}

		function updateMultiCharts(feeds) {
			const grid = document.getElementById('chartsGrid');
			grid.innerHTML = '';
			destroyMultiCharts();
			if (!feeds.length) return;
			const labels = feeds.map(f => new Date(f.created_at).toLocaleTimeString());
			Object.keys(fieldNames).forEach((key) => {
				const unit = fieldUnits[key] || '';
				const series = feeds.map(f => parseFloat(f[key])).map(v => (Number.isFinite(v) ? v : null));
				const card = document.createElement('div');
				card.className = 'card';
				const wrapper = document.createElement('div');
				wrapper.style.position = 'relative';
				wrapper.style.width = '100%';
			wrapper.style.height = '180px';
				card.innerHTML = `<h3>${fieldNames[key]}${unit ? ` [${unit}]` : ''}</h3>`;
				const canvas = document.createElement('canvas');
				wrapper.appendChild(canvas);
				card.appendChild(wrapper);
				grid.appendChild(card);
				const ctx = canvas.getContext('2d');
				const c = new Chart(ctx, {
					type: 'line',
					data: {
						labels,
						datasets: [{
							data: series,
							borderColor: '#222222',
							backgroundColor: 'transparent',
							tension: 0,
							fill: false,
							pointRadius: 0,
							spanGaps: true
						}]
					},
					options: {
						plugins: { legend: { display: false } },
						elements: { point: { radius: 0 }, line: { borderWidth: 1 } },
						maintainAspectRatio: false,
						scales: {
							x: { ticks: { color: '#444444', maxTicksLimit: 4 }, grid: { color: '#eeeeee' } },
							y: { ticks: { color: '#444444', maxTicksLimit: 4 }, grid: { color: '#eeeeee' } }
						}
					}
				});
				multiCharts.push(c);
			});
		}

		async function fetchData() {
			const channel = channelInput.value.trim();
			const key = keyInput.value.trim();
			const results = resultSelect.value;
			if (!channel || !key) {
				setStatus('Please enter Channel ID and Read API Key', false);
				return;
			}
			try {
				setStatus('Loadingâ€¦');
				const url = `https://api.thingspeak.com/channels/${channel}/feeds.json?api_key=${key}&results=${results}`;
				const res = await fetch(url);
				if (!res.ok) throw new Error('HTTP ' + res.status);
				const data = await res.json();
				lastFeeds = data.feeds || [];
				const feeds = lastFeeds;
				if (!feeds.length) {
					setStatus('No data available', false);
					return;
				}
				buildCards(feeds);
				if (isMulti) {
					updateMultiCharts(feeds);
				} else {
					updateChart(feeds);
				}
				const newest = feeds[feeds.length - 1];
				setStatus(`Updated ${new Date(newest.created_at).toLocaleTimeString()}`);
			} catch (err) {
				console.error(err);
				setStatus('Failed to load data', false);
			}
		}

		channelSelect.addEventListener('change', () => {
			const sel = channelSelect.value;
			if (channels[sel]) {
				channelInput.value = channels[sel].id;
				keyInput.value = channels[sel].readKey;
			}
			fetchData();
		});

		refreshBtn.addEventListener('click', fetchData);
		statsBtn.addEventListener('click', showStats);
		statsClose.addEventListener('click', () => statsModal.classList.remove('show'));
		statsModal.addEventListener('click', (e) => {
			if (e.target === statsModal) statsModal.classList.remove('show');
		});
		fieldSelect.addEventListener('change', () => { if (!isMulti) updateChart(lastFeeds); });

		toggleViewBtn.addEventListener('click', () => {
			isMulti = !isMulti;
			toggleViewBtn.textContent = isMulti ? 'Show Single' : 'Show All';
			fieldSelect.disabled = isMulti;
			document.getElementById('singleChartWrap').style.display = isMulti ? 'none' : '';
			document.getElementById('chartsGrid').style.display = isMulti ? '' : 'none';
			if (isMulti) {
				if (chart) { chart.destroy(); chart = null; }
				updateMultiCharts(lastFeeds);
			} else {
				destroyMultiCharts();
				updateChart(lastFeeds);
			}
		});
		// Auto-refresh every 60 seconds
		setInterval(fetchData, 60000);

		// init
		buildFieldSelector();
		fetchData();
	</script>
</body>
</html>
